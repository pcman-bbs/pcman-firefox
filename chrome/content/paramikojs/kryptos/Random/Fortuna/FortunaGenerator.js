kryptos.random.Fortuna.FortunaGenerator = {};

kryptos.random.Fortuna.FortunaGenerator.AESGenerator = function() {
  /*
    The Fortuna "generator"

    This is used internally by the Fortuna PRNG to generate arbitrary amounts
    of pseudorandom data from a smaller amount of seed data.

    The output is generated by running AES-256 in counter mode and re-keying
    after every mebibyte (2**16 blocks) of output.
  */

  this.counter = new paramikojs.util.Counter(this.block_size * 8, 0);
  this.key = null;

  // Set some helper constants
  this.block_size_shift = 4; // exact_log2(this.block_size);

  this.blocks_per_key = 2; // exact_div(this.key_size, this.block_size);

  this.max_bytes_per_request = this.max_blocks_per_request * this.block_size;
}

kryptos.random.Fortuna.FortunaGenerator.AESGenerator.prototype = {
  block_size : 16,     // output block size in octets (128 bits)
  key_size : 32,       // key size in octets (256 bits)

  // Because of the birthday paradox, we expect to find approximately one
  // collision for every 2**64 blocks of output from a real random source.
  // However, this code generates pseudorandom data by running AES in
  // counter mode, so there will be no collisions until the counter
  // (theoretically) wraps around at 2**128 blocks.  Thus, in order to prevent
  // Fortuna's pseudorandom output from deviating perceptibly from a true
  // random source, Ferguson and Schneier specify a limit of 2**16 blocks
  // without rekeying.
  max_blocks_per_request : Math.pow(2, 16),  // Allow no more than this number of blocks per _pseudo_random_data request

  _four_kiblocks_of_zeros : new Array(16 * 4096 + 1).join("\0"), // 16 == block_size

  reseed : function(seed) {
    if (!this.key) {
      this.key = new Array(this.key_size + 1).join("\0");
    }
    this._set_key(new kryptos.random.Fortuna.SHAd256(this.key + seed).digest());
    this.counter.call();  // increment counter
  },

  pseudo_random_data : function(bytes) {
    var num_full_blocks = bytes >> 20;
    var remainder = bytes & ((1<<20)-1);

    var retval = [];
    for (var i = 0; i < num_full_blocks; ++i) {
      retval.push(this._pseudo_random_data(1<<20));
    }
    retval.push(this._pseudo_random_data(remainder));

    return retval.join("");
  },

  _set_key : function(key) {
    this.key = key;
    this._cipher = new kryptos.cipher.AES(key, kryptos.cipher.AES.MODE_CTR, 0, this.counter);
  },

  _pseudo_random_data : function(bytes) {
    var num_blocks = Math.ceil(1.0 * bytes / this.block_size_shift);   // num_blocks = ceil(bytes / self.block_size)

    // Compute the output
    var retval = this._generate_blocks(num_blocks).substring(0, bytes);

    // Switch to a new key to avoid later compromises of this output (i.e.
    // state compromise extension attacks)
    this._set_key(this._generate_blocks(this.blocks_per_key));

    return retval;
  },

  _generate_blocks : function(num_blocks) {
    var retval = [];
    for (var i = 0; i < num_blocks >> 12; ++i) {      // xrange(num_blocks / 4096)
      retval.push(this._cipher.encrypt(this._four_kiblocks_of_zeros));
    }
    var remaining_bytes = (num_blocks & 4095) << this.block_size_shift;  // (num_blocks % 4095) * self.block_size
    retval.push(this._cipher.encrypt(this._four_kiblocks_of_zeros.substring(0, remaining_bytes)));
    return retval.join("");
  }
};
